
/**
 * @file s21_truncate.c
 * @brief Реализация функции отбрасывания дробной части decimal числа
 * @details Удаляет дробную часть числа (округление к нулю)
 */

#include <stdint.h>  // Типы фиксированной ширины

#include "s21_decimal.h"

/**
 * @brief Деление 96-битного числа на 10 на месте
 * @param bits Массив битов decimal числа (первые 3 элемента)
 * @details Выполняет целочисленное деление мантиссы на 10
 *          Остаток отбрасывается (эффект truncate)
 */
static void div10_u96_inplace(int bits[4]) {
  uint64_t rem = 0;  // Остаток от предыдущего деления

  // Идем от старшего разряда к младшему
  for (int i = 2; i >= 0; --i) {
    // Формируем текущее число: остаток + новый разряд
    uint64_t cur = (rem << 32) | (uint32_t)bits[i];
    uint32_t q = (uint32_t)(cur / 10u);  // Частное
    rem = (uint32_t)(cur % 10u);         // Новый остаток
    bits[i] = (int)q;                    // Записываем частное обратно
  }
  // Остаток отбрасываем - это дает эффект truncate
}

/**
 * @brief Отбросить дробную часть числа (округление к нулю)
 * @param value Исходное число
 * @param result Указатель для сохранения результата
 * @return 0 при успехе, 1 при ошибке (некорректный указатель)
 * @details Удаляет дробную часть путем деления мантиссы на 10^scale
 *          и установки масштаба в 0. Знак числа сохраняется.
 *          Примеры: 123.456 → 123, -78.9 → -78
 */
int s21_truncate(s21_decimal value, s21_decimal* result) {
  if (result) {
    // Копируем исходное число
    *result = value;

    // Получаем масштаб (количество цифр после запятой)
    int s = s21_get_scale(&value);

    // Делим мантиссу на 10 столько раз, сколько указывает масштаб
    while (s-- > 0) {
      div10_u96_inplace(result->bits);  // Деление на 10 с отбрасыванием остатка
    }

    // Обнуляем биты масштаба и знака
    result->bits[3] = 0;
    // Восстанавливаем знак (масштаб становится 0)
    s21_set_sign(result, s21_get_sign(&value));
  }

  // Возвращаем код ошибки: 0 если result корректен, 1 если NULL
  return !result;
}
