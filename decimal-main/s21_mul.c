/**
 * @file s21_mul.c
 * @brief Реализация функции умножения decimal чисел
 * @details Содержит алгоритм умножения двух 96-битных чисел с получением
 *          192-битного результата и последующим масштабированием
 */

#include <stdint.h>  // Типы фиксированной ширины
#include <stdio.h>   // Стандартные функции ввода-вывода

#include "s21_decimal.h"

// Макрос для подавления предупреждений о неиспользуемых переменных
#ifndef S21_UNUSED
#if defined(__GNUC__) || defined(__clang__)
#define S21_UNUSED __attribute__((unused))
#else
#define S21_UNUSED
#endif
#endif

typedef uint32_t U32;  // Сокращение для 32-битного беззнакового типа

/**
 * @brief Умножение двух 96-битных чисел с получением 192-битного результата
 * @param a Первый множитель (96 бит)
 * @param b Второй множитель (96 бит)
 * @param out Результат умножения (192 бита, массив из 6 элементов)
 * @details Использует алгоритм умножения "в столбик" с переносом
 */
static void mul96(const U32 a[3], const U32 b[3], U32 out[6]) {
  // Обнуляем результат
  for (int i = 0; i < 6; ++i) out[i] = 0u;

  // Перебираем все разряды первого числа
  for (int i = 0; i < 3; ++i) {
    uint64_t carry = 0u;  // Перенос между разрядами

    // Перебираем все разряды второго числа
    for (int j = 0; j < 3; ++j) {
      // Вычисляем произведение текущих разрядов + старое значение + перенос
      uint64_t cur =
          (uint64_t)out[i + j] + (uint64_t)a[i] * (uint64_t)b[j] + carry;
      out[i + j] = (U32)(cur & 0xFFFFFFFFu);  // Младшие 32 бита
      carry = cur >> 32;                      // Старшие 32 бита - это перенос
    }
    out[i + 3] += (U32)carry;  // Добавляем финальный перенос
  }
}

/**
 * @brief Деление многоразрядного числа на 10 с получением остатка
 * @param a Массив разрядов числа (изменяется)
 * @param n Количество разрядов в числе
 * @return Остаток от деления на 10
 * @details Выполняет деление "в столбик" от старших разрядов к младшим
 */
static U32 divmod10_uN(U32* a, int n) {
  uint64_t rem = 0u;  // Остаток от предыдущего деления

  // Идем от старшего разряда к младшему
  for (int i = n - 1; i >= 0; --i) {
    uint64_t cur = (rem << 32) | a[i];  // Текущее число: остаток + новый разряд
    U32 q = (U32)(cur / 10u);           // Частное
    rem = cur % 10u;                    // Новый остаток
    a[i] = q;                           // Записываем частное обратно
  }
  return (U32)rem;  // Возвращаем финальный остаток
}

/**
 * @brief Прибавление малого числа к многоразрядному числу
 * @param a Многоразрядное число (изменяется)
 * @param n Количество разрядов
 * @param add Прибавляемое число
 * @return Перенос за пределы числа
 * @details Используется для округления при делении
 */
static U32 add_small_uN(U32* a, int n, U32 add) {
  uint64_t carry = add;  // Начальное значение переноса

  // Проходим по всем разрядам, пока есть перенос
  for (int i = 0; i < n && carry; ++i) {
    uint64_t cur = (uint64_t)a[i] + carry;  // Прибавляем перенос
    a[i] = (U32)(cur & 0xFFFFFFFFu);        // Младшие 32 бита
    carry = cur >> 32;                      // Новый перенос
  }
  return (U32)carry;  // Возвращаем финальный перенос
}

/**
 * @brief Получение остатка от деления на 10 без изменения числа
 * @param a Многоразрядное число
 * @param n Количество разрядов
 * @return Остаток от деления на 10
 * @details Создает копию числа для безопасного вычисления остатка
 */
static U32 mod10_copy(const U32* a, int n) {
  U32 tmp[6];  // Временная копия (максимум 6 разрядов)
  for (int i = 0; i < n; ++i) tmp[i] = a[i];  // Копируем число
  return divmod10_uN(tmp, n);                 // Возвращаем остаток
}

/**
 * @brief Деление на 10 с банковским округлением
 * @param a Многоразрядное число (изменяется)
 * @param n Количество разрядов
 * @return Перенос при округлении вверх
 * @details Реализует банковское округление: если остаток = 5,
 *          округляем к четному последнему разряду
 */
static int round_div10_uN(U32* a, int n) {
  int result = 0;
  U32 r = divmod10_uN(a, n);  // Делим на 10, получаем остаток

  if (r > 5) {  // Если остаток > 5 - округляем вверх
    result = add_small_uN(a, n, 1u);
  } else if (5 == r) {  // Если остаток = 5 - банковское округление
    U32 last_dec_digit = mod10_copy(a, n);  // Получаем последнюю цифру
    if (last_dec_digit & 1u) {              // Если последняя цифра нечетная
      result = add_small_uN(a, n, 1u);      // Округляем вверх
    }
  }
  // Если остаток < 5 или = 5 и последняя цифра четная - не округляем
  return result;
}

/**
 * @brief Проверка, помещается ли 192-битное число в 96 бит
 * @param a192 192-битное число (массив из 6 элементов)
 * @return 1 если помещается, 0 если нет
 * @details Проверяет, равны ли нулю старшие 96 бит
 */
static int fits_in_96(const U32 a192[6]) {
  return (a192[3] == 0u && a192[4] == 0u && a192[5] == 0u);
}

/**
 * @brief Извлечение младших 96 бит из 192-битного числа
 * @param a192 192-битное число
 * @param out96 Результат - младшие 96 бит
 * @details Просто копирует первые 3 элемента массива
 */
static void low96_from_192(const U32 a192[6], U32 out96[3]) {
  out96[0] = a192[0];
  out96[1] = a192[1];
  out96[2] = a192[2];
}

/**
 * @brief Умножение двух decimal чисел
 * @param value_1 Первый множитель
 * @param value_2 Второй множитель
 * @param result Указатель для сохранения результата
 * @return 0 при успехе, 1 при переполнении положительного, 2 при переполнении
 * отрицательного
 * @details Умножает мантиссы, складывает масштабы, вычисляет знак результата
 */
int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal* result) {
  // Обнуляем результат
  result->bits[0] = result->bits[1] = result->bits[2] = result->bits[3] = 0;

  // Извлекаем знаки чисел (31-й бит)
  int sign1 = ((unsigned)value_1.bits[3] >> 31) & 1;
  int sign2 = ((unsigned)value_2.bits[3] >> 31) & 1;

  // Извлекаем масштабы чисел (биты 16-23)
  int scale1 = (value_1.bits[3] >> 16) & 0xFF;
  int scale2 = (value_2.bits[3] >> 16) & 0xFF;
  int initial_scale = scale1 + scale2;  // Итоговый масштаб

  // Извлекаем 96-битные мантиссы
  U32 a[3], b[3];
  u96_from_dec(&value_1, a);
  u96_from_dec(&value_2, b);

  // Умножаем мантиссы (получаем 192-битный результат)
  U32 prod[6];
  mul96(a, b, prod);

  int scale = initial_scale;

  // Приводим результат к 96-битному формату
  while (!fits_in_96(prod)) {
    if (scale > 0) {
      // Если есть запас масштаба - уменьшаем его
      (void)round_div10_uN(prod, 6);
      scale -= 1;
    } else if (initial_scale > 0) {
      // Если масштаб уже 0, но изначально был больше - продолжаем деление
      (void)round_div10_uN(prod, 6);
      initial_scale -= 1;
    } else {
      // Переполнение: результат не помещается в decimal
      return (sign1 ^ sign2) ? 2
                             : 1;  // 2 для отрицательного, 1 для положительного
    }
  }

  // Приводим масштаб к допустимому диапазону (0-28)
  while (scale > 28) {
    (void)round_div10_uN(prod, 6);
    scale -= 1;
  }

  // Формируем финальный результат
  U32 out96[3];
  low96_from_192(prod, out96);  // Извлекаем младшие 96 бит
  u96_to_dec(out96, result);    // Записываем в decimal

  // Устанавливаем масштаб в результате
  result->bits[3] |= (U32)((scale & 0xFF) << 16);

  // Устанавливаем знак результата (XOR знаков операндов)
  if ((sign1 ^ sign2) != 0) result->bits[3] |= (1u << 31);

  return 0;  // Успех
}
