// Реализация функции умножения десималь чисел

/*
Содержит алгоритм умножения 2х 96-бит чисел с получением 
192-бит результата и последующим масштабированием
*/
#include <stdint.h>  // Типы фиксированной ширины
#include <stdio.h>   // Стандартные функции ввода-вывода

#include "../s21_decimal.h"


// Умножение двух 96-битных чисел с получением 192-бит результата
/*
Результат умножения (192 бита, массив из 6 элементов)
Использует алгоритм умножения "в столбик" с переносом
*/

static void mul96(const uint32_t a[3], const uint32_t b[3], uint32_t out[6]){

    // Обнуляем результат
    for(int i = 0; i < 6; i++) out[i] = 0u;

    // Перебираем все разряды первого числа
    for(int i = 0; i < 3; i++){

        // Создаем перенос между разрядам
        uint32_t carry = 0u;

        // Перебираем все разряды второго числа
        for(int j = 0; j < 3; j++){

            // Вычисляем произведение текущих разрядов + старое значение + перенос
            uint64_t cur = (uint64_t)out[i+j] + (uint64_t)a[i]*(uint64_t)b[j] + carry;
        
            // Младшие 32 бита записываем в текущую ячейку
            out[i+j] = (uint32_t)(cur & 0xFFFFFFFF);

            // Старшие 32 бита - оставляем для переноса
            carry = cur >> 32;
        }

        // финальный перенос для самого левого разряда
        out[i+3] += (uint32_t)carry; 

    }
}


// Деление многоразрядного числа на 10 с получением остатка
// Выполняет деление "в столбик" от старших разрядов к младшим

static uint32_t divmod10_uN(uint32_t* a, int n){

    // Остаток от предыдущего деления
    uint64_t rem = 0u;

    // Идем от старшего разряда к младшему
    for(int i = n - 1; i >= 0; i--){

        // текущее число: предыдущий остаток в старший разряд + новый разряд
        uint64_t cur = (rem << 32) | a[i];

        // целая часть от деления на 10
        uint32_t q = (uint32_t)(cur / 10u);

        // новый остаток от деления на 10
        rem = cur % 10;

        // записываем частное обратно в текущую ячейку памяти
        a[i] = q;
    }

    // возвращаем финальный остаток
    return (uint32_t)rem;
}

// Прибавление малого числа к многоразрядному числу
// Используется для округления при делении

static uint32_t add_small_uN(uint32_t* a, int n, uint32_t add){

    // задаем начальное значение переноса
    uint64_t carry = add;

    // Проходим по всем разрядам, пока есть перенос
    for(int i = 0; i < n && carry; i++){

        // Прибавляем число add(перенос)
        uint64_t cur = (uint64_t)a[i] + carry;

        // Оставляем младшие 32 бита в текущем разряде
        a[i] = (uint32_t)(cur & 0xFFFFFFFF);

        // считаем новый перенос как старшие 32 бита(смещаем младшие 32 бита нах)
        carry = cur >>32;
    }

    // возвращаем финальный перенос (переполнение)
    return (uint32_t)carry;
}

// Получение остатка от деления на 10 без изменения числа
// Создает копию числа для безопасного вычисления остатка

static uint32_t mod10_copy(const uint32_t* a, int n){

    // Временная копия (максимум 6 разрядов)
    uint32_t tmp[6];

    // Копируем число всплоть до заданного разряда
    for(int i = 0; i < n; i++) tmp[i] = a[i];

    // Возвращаем остаток от деления копии на 10
    return divmod10_uN(tmp, n);
}


// Деление на 10 с банковским округлением
// Реализует банковское округление, если остаток = 5 - округляем к четному последнему разряду

static int round_div10_uN(uint32_t* a, int n){

    int result = 0;

    // Делим на 10, получаем остаток
    uint32_t r = divmod10_uN(a,n);

    // если остаток > 5 - округляем вверх
    if(r > 5){

        // добавляем единицу к числу и получаем перенос(переполнение)
        result = add_small_uN(a, n, 1u);
    } else if (r == 5){  // если  остаток = 5 - банковское округление

        // Получаем последнюю цифру, после деления числа на 10 (это будет как раз остаток деления на 10)
        uint32_t last_digit = mod10_copy(a, n);

        // Если эта цифра - нечетная
        if (last_digit & 1u){

            //прибавляем единицу и получаем переполнение
            result = add_small_uN(a, n, 1u);
        }
    }

    // Если остаток < 5 или = 5 и последняя цифра - четная, то не окргуляем
    // возвращаем переполнение
    return result;
}

// Проверка - помещается ли 192 бит число в 96 бит
// Проверяет, равны ли нулю старшие 96 бит

static int fits_in_96(const uint32_t a192[6]){
    return (a192[3] == 0u && a192[4] == 0u && a192[5] == 0u);
}

// Извлечение младших 96 бит из 192-бит числа\=
// Просто копирует первые 3 элемента массива

static void low96_from_192(const uint32_t a192[6], uint32_t out96[3]){
    out96[0] = a192[0];
    out96[1] = a192[1];
    out96[2] = a192[2];
}

// Умножение двух decimal чисел
// Умножает мантиссы, складывает масштабы, вычисляет знак результата

int s21_mul(s21_decimal value_1, s21_decimal value_2, s21_decimal* result) {

    // Обнуляем результат
    result->bits[0] = result->bits[1] = result->bits[2] = result->bits[3] = 0u;

    // Извлекаем знаки чисел (31-й бит)
    int sign1 = ((unsigned)value_1.bits[3] >> 31) & 1;
    int sign2 = ((unsigned)value_2.bits[3] >> 31) & 1;

    // Извлекаем масштабы чисел (биты 16-23)
    int scale1 = (value_1.bits[3] >> 16) & 0xFF;
    int scale2 = (value_2.bits[3] >> 16) & 0xFF;
    // Итоговый масштаб (При умножении)
    int initial_scale = scale1 + scale2;

    // Извлекаем 96-бит мантиссы
    uint32_t a[3], b[3];
    u96_from_dec(&value_1, a);
    u96_from_dec(&value_2, b);

    // Умножаем мантиссы (получаем 192-битный результат)
    uint32_t prod[6];
    mul96(a, b, prod);

    // Текущий масштаб - итоговый
    int scale = initial_scale;

    // Приводим результат к 96-бит формату
    while (!fits_in_96(prod)) {

        // если есть запас масштаба - уменьшаем его
        if(scale > 0){

            // Делим на 10 и округляем мантиссу (значение переполнения теряется)
            (void)round_div10_uN(prod, 6);
            // уменьшаем масштаб
            initial_scale--;
        } /*else if(initial_scale > 0){
            (void)round_div10_uN(prod, 6);
            initial_scale -= 1;
        } */else {
            
            // Переполнение: целая часть не помещается в 96 бит
            int err = 1;
            if(sign1 ^ sign2) // XOR для знаков, чтобы оперделить отрицательное и положительное  
                err = 2;
            else
                err = 1;
            // 2 для отрицательного, 1 для положительного 

            return err;
        }
    }

    // Приводим масштаб к допустимому диапазону (0-28)
    while (scale > 28) {

        // Делим на 10 мантиссу, округляем ее и уменьшаем масштаб
        (void)round_div10_uN(prod, 6);
        scale -= 1;
    }

    // Формируем финальный результат
    uint32_t out96[3];
    // Извлекаем младшие 96 бит в мантиссу
    low96_from_192(prod, out96);
    // Записываем мантиссу в десималь
    u96_to_dec(out96, result);

    // Устанавливаем масштаб в результате
    result->bits[3] |= (uint32_t)( (scale & 0xFF) << 16);

    // Устанавливаем знак результата ( XOR для операндов)
    if ((sign1 ^ sign2) != 0) result->bits[3] |= (1u << 31);

    // Успех
    return 0;
}
