// Реализация функции деления decimal чисел

#include "../s21_decimal.h"

/*
Содержит алгоритм деления с поддержкой точности до 28 знаков
после запятой и банковского округления
*/

// Сдвиг 96-битного числа влево на 1 бит
// Используется в алгоритме деления для сдвига остатка

static inline uint32_t u96_shl1(uint32_t a[3]){

    // Бит перехода из 0-го разряда в 1-й
    uint32_t c0 = (a[0] >> 31) & 1u;

    // Бит перехода из 1-го разряда во 2-й
    uint32_t c1 = (a[1] >> 31) & 1u;

    // Бит, который "выпадает" из числа
    uint32_t c2 = (a[2] >> 31) & 1u;

    //Сдвигаем младший разряд
    a[0] <<= 1;

    // Сдвигаем средний + бит от младшего
    a[1] = (a[1] << 1) | c0;

    // Сдвигаем старший + бит от среднего
    a[2] = (a[2] << 1) | c1;

    // Возвращаем "выпавший" бит
    return c2;
}

// Установка младшего бита 96-битного числа
// Используется для записи очередного бита результата деления

static inline void u96_or1(uint32_t a[3], uint32_t bit){
    a[0] = a[0] | (bit & 1u);
}

// Деление 96-битного числа на 96-битное с получением частного и остатка
// Реализует алгоритм деления "в столбик" для двоичных чисел
static void u96_divmod(const uint32_t a_in[3], const uint32_t b_in[3], uint32_t q_out[3], uint32_t r_out[3]){

    // Создаем рабочие копии входных данных
    uint32_t a[3] = {a_in[0], a_in[1], a_in[2]}; // Делимое
    uint32_t b[3] = {b_in[0], b_in[1], b_in[2]}; // Делитель
    uint32_t q[3] = {0, 0, 0};                   // Частное
    uint32_t r[3] = {0, 0, 0};                   // Остаток

    // Обрабатываем каждый бит делимого от старшего к младшему
    for(int bit = 95; bit >= 0; bit--){
        // Сдвигаем остаток влево (получаем перенос)
        uint32_t carry = u96_shl1(r);
        // Игнорируем перенос (не используется)
        (void)carry;

        // Определяем позицию текущего бита в массиве
        int limb = bit / 32;  // Номер элемента массива
        int off = bit % 32;   // Позиция бита в элементе

        // Извлекаем текущий бит делимого
        uint32_t abit = (a[limb] >> off) & 1u;
        //Добавляем его к остатку
        u96_or1(r, abit);

        // Если остаток >= делителя, то можем вычесть
        if( u96_compare(r, b) >= 0 ){
            // Вычитаем делитель из остатка
            (void)u96_sub(r, b);
            // Устанавливаем соответствующий бит частного
            q[limb] |= (1u << off); 
        }
    }

    // Копируем результаты в выходные параметры
    q_out[0] = q[0];
    q_out[1] = q[1];
    q_out[2] = q[2];
    r_out[0] = r[0];
    r_out[1] = r[1];
    r_out[2] = r[2];
}

// Определение необходимости банковского округления
// Реализует правило банковского округления для деления, 1 - вверх, 0 иначе

static int banker_should_increment(const uint32_t R[3],const uint32_t D[3], const uint32_t curQ[3]){

    int result = 0;
    // Копия остатка
    uint32_t tmp[3] = {R[0], R[1], R[2]};
    // Умножаем остаток на 10
    (void)u96_mul10(tmp);

    uint32_t qd[3], rd[3];
    // получаем первый знак после запятой remain
    u96_divmod(tmp, D, qd, rd);
    uint32_t remain = qd[0];
    int tail_nonzero = !(rd[0] == 0u && rd[1] == 0u && rd[2] == 0u);

    // банковскоe округления
    if(remain < 5u) result = 0;
    else if(remain > 5 || tail_nonzero) result = 1;
    else result = (curQ[0] & 1u) != 0u;

    return result;
}

// обрабатывает переполнение при округлении
static int handle_div_overflow_and_round(s21_decimal* out, int S, int sign, const uint32_t R[3], const uint32_t D[3]){

    int result = 0;
    // смотрим нужно ли округлять вверх
    int inc = banker_should_increment( R, D, (uint32_t[]){(uint32_t)out->bits[0], (uint32_t)out->bits[1], (uint32_t)out->bits[2]});
    
    // если нужно
    if(inc){
        uint32_t one[3] = {1, 0, 0};
        // если есть переполнение при добавлении
        if(u96_add((uint32_t*)&out->bits[0], one)) {
            // если масштаб больше 0
            if(S) {
                // округляем в нижнюю сторону
                s21_scale_down_one_banker(out);
                // снова добавляем единицу
                u96_add((uint32_t*)&out->bits[0], one);
            } else {
                // если масштаб не позволяет уменьшать число - ошибка
                if(sign) result = 2;
                else result = 1;
            }
        }
    }

    return result;
}

// Деление двух decimal чисел
// Выполняет точное деление с поддержкой до 28 знаков после запятой
int s21_div(s21_decimal value_1, s21_decimal value_2, s21_decimal* result) {

    int err = 0;

    // Проверка корректности указателя результата
    if(!result) return 1;

    // Проверка деления на 0
    if(value_2.bits[0] == 0 && value_2.bits[1] == 0 && value_2.bits[2] == 0){
        // Ошибка: деление на ноль
        return 3;
    }

    // Если делимое равно нулю, результат тоже ноль
    if(value_1.bits[0] == 0 && value_1.bits[1] == 0 && value_1.bits[2] == 0){
        s21_reset_value(result);
        return 0;
    }

    // Вычисляем знак результата (XOR знаков операндов)
    int sign = s21_get_sign(&value_1) ^ s21_get_sign(&value_2);

    // Получаем масштабы чисел
    int Sa = s21_get_scale(&value_1); 
    int Sb = s21_get_scale(&value_2);
    int E = Sa - Sb;

    // инициализация переменных
    uint32_t Q[3] = {0, 0, 0};
    uint32_t R[3] = {0, 0, 0};
    uint32_t N[3], D[3];
    u96_from_dec(&value_1, N);
    u96_from_dec(&value_2, D);

    // Основное деление
    u96_divmod(N, D, Q, R);

    // результат - целое число от деления
    s21_decimal out = {{0,0,0,0}};
    u96_to_dec(Q, &out);
    int S = 0;

    // пока остаток не равен нулю и масштаб меньше максимума
    while(!u96_is_zero(R) && S < S21_SCALE_MAX){

        uint32_t tmp[3] = {(uint32_t)out.bits[0], (uint32_t)out.bits[1], (uint32_t)out.bits[2]};

        // если есть переполнение 
        if(u96_mul10(tmp)) {
            err = handle_div_overflow_and_round(&out, S, sign, R, D);

            // если есть ошибка - ошибка
            if(err) return err;
            break;
        }

        // создаем копию остатка
        uint32_t r10[3] = {R[0], R[1], R[2]};

        // умножаем его на 10
        (void)u96_mul10(r10);
        uint32_t qd[3], rd[3];

        // делим снова на делитель чтобы получить первую цифру
        u96_divmod(r10, D, qd, rd);
        uint32_t digit = qd[0];

        // qd - и есть первая цифра
        uint32_t digit_u96[3] = {digit, 0, 0};

        // если переполнение при добавлении первой цифры x*10+y = xy типа 11*10 + 5 = 115
        if(u96_add(tmp, digit_u96)){

            // округление при переполнении
            err = handle_div_overflow_and_round(&out, S, sign, R, D);
            if(err) return err;
        }
        u96_to_dec(tmp, &out);
        S++;

        // копируем в старый остаток новый остаток
        u96_copy(R,rd);
    }

    // если масштаб делителя меньше делимого и нам нужно делить результат
    if( E > 0) {

        // прибавляем разницу масштабов делителя и делимого к S так как в формуле 10^(-S)
        int targetS = S + E;

        // пока текущий масштаб больше 28
        while (targetS > S21_SCALE_MAX){
            // округляем и уменьшаем масштаб
            s21_scale_down_one_banker(&out);
            targetS--;
        }

        // обновляем масштаб числа
        S = targetS;
    } else
    // если масштаб делителя > масштаба делимого то нам нужно умножать результат
    if (E < 0){
        // переменная - сколько раз умножить на 10 
        int need = -E; 

        // пока нужно умножать
        while(need > 0){

            // временная переменная для хранения промежуточного результата
            uint32_t a[3] = {(uint32_t)out.bits[0], (uint32_t)out.bits[1], (uint32_t)out.bits[2]};
            
            // если есть переполнение при умножении этой промежуточной переменной на 10
            if(u96_mul10(a)){

                // если масштаб не уменьшить
                if(S == 0){
                    if(sign) return 2;
                    else return 1;
                }

                // устанавливаем в переменную масштаб
                s21_set_scale(&out, S);

                // понижаем масштаб на 1 и округляем
                s21_scale_down_one_banker(&out);

                // получаем текущий масштаб
                S = s21_get_scale(&out);

            } else { // иначе если нет переполнения при умножении на 10

                // помещаем текущую умноженную переменную на 10 в мантиссу
                u96_to_dec(a, &out);

                // понижаем количество требуемых умножений
                need--;
            }
        }
    }

    // устанавливаем масштаб, знак и проверяем мантиссу на 0
    s21_set_scale(&out, S);
    s21_set_sign(&out, sign);

    if(s21_is_zero(&out)){
        s21_set_sign(&out, 0);
    }

    *result = out;
    return 0;

}

