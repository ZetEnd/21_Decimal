// Реализация функции умножения десималь чисел

/*
Содержит алгоритм умножения 2х 96-бит чисел с получением 
192-бит результата и последующим масштабированием
*/
#include <stdint.h>  // Типы фиксированной ширины
#include <stdio.h>   // Стандартные функции ввода-вывода

#include "../s21_decimal.h"


// Умножение двух 96-битных чисел с получением 192-бит результата
/*
Результат умножения (192 бита, массив из 6 элементов)
Использует алгоритм умножения "в столбик" с переносом
*/

static void mul96(const uint32_t a[3], const uint32_t b[3], uint32_t out[6]){

    // Обнуляем результат
    for(int i = 0; i < 6; i++) out[i] = 0u;

    // Перебираем все разряды первого числа
    for(int i = 0; i < 3; i++){

        // Создаем перенос между разрядам
        uint32_t carry = 0u;

        // Перебираем все разряды второго числа
        for(int j = 0; j < 3; j++){

            // Вычисляем произведение текущих разрядов + старое значение + перенос
            uint32_t cur = (uint64_t)out[i+j] + (uint64_t)a[i]*(uint64_t)b[j] + carry;
        
            // Младшие 32 бита записываем в текущую ячейку
            out[i+j] = (uint32_t)(cur & 0xFFFFFFFF);

            // Старшие 32 бита - оставляем для переноса
            carry = cur >> 32;
        }

        // финальный перенос для самого левого разряда
        out[i+3] += (uint32_t)carry; 

    }
}


// Деление многоразрядного числа на 10 с получением остатка
// Выполняет деление "в столбик" от старших разрядов к младшим

static uint32_t divmod10_uN(uint32_t* a, int n){

    // Остаток от предыдущего деления
    uint64_t rem = 0u;

    // Идем от старшего разряда к младшему
    for(int i = n - 1; i >= 0; i--){

        // текущее число: предыдущий остаток в старший разряд + новый разряд
        uint64_t cur = (rem << 32) | a[i];

        // целая часть от деления на 10
        uint32_t q = (uint32_t)(cur / 10u);

        // новый остаток от деления на 10
        rem = cur % 10;

        // записываем частное обратно в текущую ячейку памяти
        a[i] = q;
    }

    // возвращаем финальный остаток
    return (uint32_t)rem;
}

// Прибавление малого числа к многоразрядному числу
// Используется для округления при делении

static uint32_t add_small_uN(uint32_t* a, int n, uint32_t add){

    // задаем начальное значение переноса
    uint64_t carry = add;

    // Проходим по всем разрядам, пока есть перенос
    for(int i = 0; i < n && carry; i++){

        // Прибавляем число add(перенос)
        uint64_t cur = (uint64_t)a[i] + carry;

        // Оставляем младшие 32 бита в текущем разряде
        a[i] = (uint32_t)(cur & 0xFFFFFFFF);

        // считаем новый перенос как старшие 32 бита(смещаем младшие 32 бита нах)
        carry = cur >>32;
    }

    // возвращаем финальный перенос (переполнение)
    return (uint32_t)carry;
}

// Получение остатка от деления на 10 без изменения числа
// Создает копию числа для безопасного вычисления остатка

static uint32_t mod10_copy(const uint32_t* a, int n){

    // Временная копия (максимум 6 разрядов)
    uint32_t tmp[6];

    // Копируем число всплоть до заданного разряда
    for(int i = 0; i < n; i++) tmp[i] = a[i];

    // Возвращаем остаток от деления копии на 10
    return divmod10_uN(tmp, n);
}


// Деление на 10 с банковским округлением
// Реализует банковское округление, если остаток = 5 - округляем к четному последнему разряду
static int round_div10_uN(uint32_t* a, int n){

    int result = 0;

    // Делим на 10, получаем остаток
    uint32_t r = divmod10_uN(a,n);

    // если остаток > 5 - округляем вверх
    if(r > 5){

        // добавляем единицу к числу и получаем перенос(переполнение)
        result = add_small_uN(a, n, 1u);
    } else if (r == 5){  // если  остаток = 5 - банковское округление

        // Получаем последнюю цифру, после деления числа на 10 (это будет как раз остаток деления на 10)
        uint32_t last_digit = mod10_copy(a, n);

        // Если эта цифра - нечетная
        if (last_digit & 1u){

            //прибавляем единицу и получаем переполнение
            result = add_small_uN(a, n, 1u);
        }
    }

    // Если остаток < 5 или = 5 и последняя цифра - четная, то не окргуляем
    // возвращаем переполнение
    return result;
}