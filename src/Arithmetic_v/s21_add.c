/**
 * @file s21_add.c
 * @brief Реализация функции сложения decimal чисел
 * @details Содержит основную функцию s21_add и вспомогательные функции
 *          для работы с масштабированием и округлением
 */

#include <stdint.h>  // Типы фиксированной ширины
#include <string.h>  // Функции работы с памятью (memset)

#include "../s21_decimal.h"

// Сокращения для типов данных
typedef uint32_t U32;  // 32-битное беззнаковое число
typedef uint64_t U64;  // 64-битное беззнаковое число

/**
 * @brief Банковское округление после деления на 10 для 96-битного числа
 * @param a 96-битное число для округления
 * @param rem Остаток от деления на 10
 * @details Если остаток > 5 или равен 5 и число нечетное, то округляем вверх
 */
static void bankers_round_after_div10_96(U32 a[3], U32 rem) {
  // Если остаток > 5 или остаток = 5 и число нечетное (младший бит = 1)
  if (rem > 5u || (rem == 5u && (a[0] & 1u))) {
    U32 one[3] = {1, 0, 0};  // Число 1 в формате 96-bit
    (void)u96_add(a, one);   // Прибавляем 1 (игнорируем переполнение)
  }
}

/**
 * @brief Удаление незначащих нулей в конце числа
 * @param a 96-битное число
 * @param scale Указатель на масштаб числа
 * @details Уменьшает масштаб, деля число на 10, пока это возможно
 */
static void strip_trailing_zeros(U32 a[3], int* scale) {
  U32 tmp[3] = {0, 0, 0};  // Временный массив
  u96_copy(tmp, a);        // Копируем исходное число

  // Пока масштаб > 0 и деление на 10 дает остаток 0
  while (*scale > 0 && 0 == u96_div10(tmp)) {
    u96_copy(a, tmp);  // Сохраняем результат деления
    --(*scale);        // Уменьшаем масштаб
    u96_copy(tmp, a);  // Готовим к следующей итерации
  }
}

/**
 * @brief Деление 128-битного числа на 10
 * @param a 128-битное число (массив из 4 элементов)
 * @return Остаток от деления
 * @details Выполняет деление "в столбик" от старших разрядов к младшим
 */
static U32 u128_div10(U32 a[4]) {
  U64 rem = 0;  // Остаток от предыдущего деления

  // Идем от старшего разряда к младшему
  for (int i = 3; i >= 0; --i) {
    U64 cur = (rem << 32) | a[i];  // Текущее число: остаток + новый разряд
    a[i] = (U32)(cur / 10u);       // Частное записываем обратно
    rem = cur % 10u;               // Остаток для следующей итерации
  }
  return (U32)rem;  // Возвращаем финальный остаток
}

/**
 * @brief Банковское округление после деления на 10 для 128-битного числа
 * @param a 128-битное число для округления
 * @param rem Остаток от деления на 10
 * @details Прибавляет 1 к числу при необходимости округления вверх
 */
static void bankers_round_after_div10_128(U32 a[4], U32 rem) {
  // Если остаток > 5 или остаток = 5 и число нечетное
  if (rem > 5u || (rem == 5u && (a[0] & 1u))) {
    // Прибавляем 1 с учетом переноса между разрядами
    U64 s = (U64)a[0] + 1u;  // Прибавляем к младшему разряду
    a[0] = (U32)s;           // Сохраняем результат
    U64 c = s >> 32;         // Перенос в старший разряд

    if (c) {               // Если есть перенос
      s = (U64)a[1] + 1u;  // Прибавляем к следующему разряду
      a[1] = (U32)s;
      c = s >> 32;

      if (c) {  // Если снова есть перенос
        s = (U64)a[2] + 1u;
        a[2] = (U32)s;
        c = s >> 32;

        if (c) a[3] += 1u;  // Прибавляем к самому старшему разряду
      }
    }
  }
}

/**
 * @brief Приведение двух чисел к одинаковому масштабу
 * @param ax Первое число (может быть изменено)
 * @param sa Указатель на масштаб первого числа
 * @param bx Второе число (может быть изменено)
 * @param sb Указатель на масштаб второго числа
 * @details Увеличивает масштаб меньшего числа или уменьшает масштаб большего
 */
static void align_scales(U32 ax[3], int* sa, U32 bx[3], int* sb) {
  if (*sa != *sb) {  // Если масштабы разные

    // Убеждаемся, что *sa <= *sb (меняем местами если нужно)
    if (*sa > *sb) {
      U32 tmp[3];
      u96_copy(tmp, ax);  // Меняем числа местами
      u96_copy(ax, bx);
      u96_copy(bx, tmp);

      int ts = *sa;  // Меняем масштабы местами
      *sa = *sb;
      *sb = ts;
    }

    // Приводим к общему масштабу
    while (*sa < *sb) {
      U32 tmp[3];
      u96_copy(tmp, ax);

      // Пытаемся увеличить масштаб меньшего числа (умножить на 10)
      if (u96_mul10(tmp) == 0) {  // Если нет переполнения
        u96_copy(ax, tmp);        // Принимаем результат
        ++(*sa);                  // Увеличиваем масштаб
      } else {
        // Иначе уменьшаем масштаб большего числа (делим на 10)
        U32 rem = u96_div10(bx);                // Делим на 10
        bankers_round_after_div10_96(bx, rem);  // Округляем
        --(*sb);                                // Уменьшаем масштаб
      }
    }
  }
}

/**
 * @brief Сложение двух decimal чисел
 * @param value_1 Первое слагаемое
 * @param value_2 Второе слагаемое
 * @param result Указатель для сохранения результата
 * @return 0 при успехе, 1 при переполнении (слишком большое число)
 * @details Основная функция сложения, учитывающая знаки и масштабы чисел
 */
int s21_add(s21_decimal value_1, s21_decimal value_2, s21_decimal* result) {
  // Обнуляем результат
  memset(result, 0, sizeof(s21_decimal));

  // Извлекаем масштабы чисел
  int scale_a = s21_get_scale(&value_1);
  int scale_b = s21_get_scale(&value_2);

  // Извлекаем 96-битные значения чисел
  uint32_t a96[3], b96[3];
  u96_from_dec(&value_1, a96);
  u96_from_dec(&value_2, b96);

  // Приводим к общему масштабу
  align_scales(a96, &scale_a, b96, &scale_b);

  // Извлекаем знаки чисел
  int sign_a = s21_get_sign(&value_1);
  int sign_b = s21_get_sign(&value_2);

  // Переменные для результата
  U32 res96[3] = {0};  // Результирующее 96-битное число
  int sign_res = 0;    // Знак результата

  if (sign_a == sign_b) {             // Если знаки одинаковые - складываем
    u96_copy(res96, a96);             // Копируем первое число
    int carry = u96_add(res96, b96);  // Прибавляем второе, получаем перенос

    if (carry) {                   // Если есть переполнение
      if (scale_a == 0) return 1;  // Нельзя уменьшить масштаб - ошибка

      // Работаем с 128-битным числом для устранения переполнения
      U32 ext[4] = {res96[0], res96[1], res96[2], (U32)carry};

      do {
        if (scale_a == 0) return 1;  // Нельзя больше уменьшать масштаб
        U32 rem = u128_div10(ext);   // Делим на 10
        bankers_round_after_div10_128(ext, rem);  // Округляем
        --scale_a;                                // Уменьшаем масштаб
      } while (ext[3] != 0);  // Пока есть переполнение

      // Копируем обратно в 96-битный формат
      res96[0] = ext[0];
      res96[1] = ext[1];
      res96[2] = ext[2];
    }
    sign_res = sign_a;  // Знак результата = знаку слагаемых

  } else {                        // Если знаки разные - вычитаем
    int cmp = u96_compare(a96, b96);  // Сравниваем модули чисел

    if (cmp == 0) {  // Если числа равны по модулю - результат 0
      res96[0] = res96[1] = res96[2] = 0;
      scale_a = 0;
      sign_res = 0;
    } else if (cmp > 0) {    // Если |a| > |b|
      u96_copy(res96, a96);  // res = a - b
      u96_sub(res96, b96);
      sign_res = sign_a;     // Знак результата = знаку a
    } else {                 // Если |a| < |b|
      u96_copy(res96, b96);  // res = b - a
      u96_sub(res96, a96);
      sign_res = sign_b;  // Знак результата = знаку b
    }
  }

  // Удаляем незначащие нули
  strip_trailing_zeros(res96, &scale_a);

  // Формируем финальный результат
  u96_to_dec(res96, result);       // Копируем 96-битное значение
  s21_set_scale(result, scale_a);  // Устанавливаем масштаб
  s21_set_sign(result, sign_res);  // Устанавливаем знак

  return 0;  // Успех
}
